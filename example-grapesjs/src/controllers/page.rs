use actix_web::{web, patch, get, web::Path, post, web::Json, web::Data, HttpResponse};
use actix_identity::{Identity};
use models::{Page};
use tera::{Context, Tera};
use crate::{models};


#[get("/page/{id}/edit")]
pub async fn edit_page(tmpl: Data<Tera>, id: Path<i32>, user: Option<Identity>) -> HttpResponse {
    if let Some(_user) = user {
        let result = Page::get_page_by_id(id.into_inner()).await;
        match result {
            Ok(page) => {
                let mut context = Context::new();
                context.insert("title", "Edit Page");
                context.insert("route_name", "edit_page");
                context.insert("html_content", &page.html_content);
                context.insert("page", &page);
                context.insert("page_id", &page.id);
                context.insert("username", &_user.id().unwrap());
                let s = tmpl.render("layouts/authenticated_page/page/edit_page.html.tera", &context).unwrap();
                HttpResponse::Ok().body(s)
            }
            Err(e) => {
                let mut context = Context::new();
                context.insert("error", &e.to_string());
                context.insert("username", &_user.id().unwrap());
                let s = tmpl.render("layouts/authenticated_page/page/edit_page.html.tera", &context).unwrap();
                HttpResponse::Ok().body(s)
            }
        }
    } else {
        HttpResponse::Unauthorized().json("You must be logged in to edit.")
    }
}
    



#[get("/page/{slug}")]
pub async fn get_page_by_slug(tmpl: Data<Tera>, slug: Path<String>, user: Option<Identity>) -> HttpResponse {
    let result = Page::get_page_by_slug(slug.into_inner()).await;
    match result {
        Ok(page) => {
            let mut context = Context::new();
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            context.insert("title", "Create Page");
            context.insert("route_name", "create_page");
            context.insert("html_content", &page.html_content);
            context.insert("page_id", &page.id.unwrap());
            let s = tmpl.render("pages/page.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
        Err(e) => {
            let mut context = Context::new();
            context.insert("error", &e.to_string());
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            let s = tmpl.render("pages/404.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
    }
}


/// Alert: This is a generated controller.
/// The controller is generated by the rustyroad CLI.
/// It is a best guess at what the controller should look like.
/// Please review the controller and make any necessary changes.
#[post("/page")]
pub async fn create_page(page: Json<Page>,user: Option<Identity>) -> HttpResponse {
    if let Some(_user) = user {
        let result = Page::create_page(page.into_inner()).await;
        match result {
            Ok(page) => HttpResponse::Ok().json(page),
            Err(e) => {
                eprintln!("Error creating page: {:?}", e); // Log the error
                HttpResponse::BadRequest().json(e.to_string())
            }
        }
    } else {
      // redirect to login page
      let mut context = Context::new();
        context.insert("title", "Login");
        context.insert("route_name", "login");
        context.insert("error", "You must be logged in to create a new page.");
        HttpResponse::Found()
            .append_header((actix_web::http::header::LOCATION, "/login"))
            .finish()
    }
   // before we allow the user to create a new page we need to check if they are logged in
   // if they are not logged in, we need to redirect them to the login page
}

#[patch("/page/{id}")]
        pub async fn update_page(id: Path<i32>, page: Json<Page>, user: Option<Identity>) -> HttpResponse {
            if let Some(_user) = user {
                let result = Page::update_page(id.into_inner(), page.into_inner()).await;
                match result {
                    Ok(page) => HttpResponse::Ok().json(page),
                    Err(e) => HttpResponse::BadRequest().json(e.to_string()),
                }
            } else {
                HttpResponse::Unauthorized().json("You must be logged in to update.")
            }
        }


#[get("/page/{id}")]
async fn get_page_by_id(tmpl: Data<Tera>, id: Path<i32>, user: Option<Identity>) -> HttpResponse {
    let result = Page::get_page_by_id(id.into_inner()).await;
    match result {
        Ok(page) => {
            let mut context = Context::new();
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            context.insert("title", "Create Page");
            context.insert("route_name", "create_page");
            context.insert("html_content", &page.html_content);
            context.insert("page_id", &page.id.unwrap());
            let s = tmpl.render("pages/page.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
        Err(e) => {
            let mut context = Context::new();
            context.insert("error", &e.to_string());
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            let s = tmpl.render("pages/404.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
    }
}

#[get("/page/all")]
pub async fn get_all_pages() -> HttpResponse {
    let result = Page::get_all_pages().await;
    match result {
        Ok(Page) => HttpResponse::Ok().json(Page),
        Err(e) => HttpResponse::BadRequest().json(e.to_string()),
    }
}


    #[get("/page/{id}/details")]
pub async fn get_page_details(tmpl: Data<Tera>, user: Option<Identity>, id: Path<i32> ) -> HttpResponse {
    let mut context = Context::new();
    context.insert("title", "page");
    context.insert("controller_name", "page");

    let rendered = if let Some(user) = user {
        context.insert("username", &user.id().unwrap());

        let page = Page::get_page_by_id(id.into_inner()).await;

        match page {
            Ok(page) => {
                context.insert("page", &page);
                context.insert("html_content", &page.html_content);
                tmpl.render(
                    "layouts/authenticated_page/page/page_details.html.tera",
                    &context,
                )
                .unwrap()
            }
            Err(e) => {
                let mut context = Context::new();
                context.insert("error", &e.to_string());
                let page = Page::new();
                context.insert("page", &page);
                context.insert("html_content", &page.html_content);
                context.insert("title", "Create Page");
                tmpl.render(
                    "layouts/authenticated_page/page/page_details.html.tera",
                    &context,
                )
                .unwrap()
            }
        }
    } else {
        // redirect to login page
        let mut context = Context::new();
        context.insert("title", "Login");
        context.insert("route_name", "login");
        context.insert("error", "You must be logged in to create a new page.");
        tmpl.render(
            "pages/login.html.tera",
            &context,
        )
        .unwrap()
    };

    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(rendered)

}


#[get("/page/{id}/delete")]
pub async fn delete_page(tmpl: Data<Tera>, user: Option<Identity>, id: Path<i32>) -> HttpResponse {
    let result = Page::delete_page(id.into_inner()).await;
    match result {
        Ok(_) => {
            let mut context = Context::new();
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            context.insert("title", "Create Page");
            context.insert("route_name", "create_page");
            let s = tmpl.render("pages/page.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
        Err(e) => {
            let mut context = Context::new();
            context.insert("error", &e.to_string());
            if let Some(_user) = user {
                context.insert("username", &_user.id().unwrap());
            }
            let s = tmpl.render("pages/404.html.tera", &context).unwrap();
            HttpResponse::Ok()
                .content_type("text/html; charset=utf-8")
                .body(s)
        }
    }
}


